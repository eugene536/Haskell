
==================== FINAL INTERFACE ====================
2016-10-24 10:18:50.984799 UTC

interface Parse_8jvQSOrf1Ae9tCV8prCCeR:ParserSExpr 7103
  interface hash: f5b41c7fb64683a28ef564f8c7541995
  ABI hash: 68d12a684d769de58d7b656b7a6d56ef
  export-list hash: 12a724eb37055727eba6a374279c33ed
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParserSExpr.parseSExpr
module dependencies: Parser UsefulParsers
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  Parser dd420111856b97cefbec8ea69afca86e
  exports: 5dcaeb168f8770ff3c0fc30d8c671a87
  Parser 9b019ae416d0f1d5997d31a1b5bd73d5
import  -/  UsefulParsers e9fcfcd7e4a12ebf1555f219d643ed90
  exports: 84913e587f7744e2fabb60c13a05120a
  char ac3a3f181ae13e046a92344002ea5ee5
  ident d36df007db5e28bfdc7ca4f2d1d1cc5e
  oneOrMore 6282fb1325e04af0bdee0aea3939c91d
  posInt 7f2da07db9cc55cdf9a5fcdaa160cb63
  spaces 833751dd4c874129b0b2312bbfc6d286
import  -/  base-4.8.2.0:Control.Applicative a8ebf5ad4932b411ad7725da68be9801
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
bc3264b2fe8800129e52bb5e9611ac24
  $fShowAtom :: GHC.Show.Show ParserSExpr.Atom
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ParserSExpr.Atom
                  ParserSExpr.$fShowAtom_$cshowsPrec
                  ParserSExpr.$fShowAtom_$cshow
                  ParserSExpr.$fShowAtom_$cshowList -}
bc3264b2fe8800129e52bb5e9611ac24
  $fShowAtom1 :: ParserSExpr.Atom -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: ParserSExpr.Atom w1 :: GHC.Base.String ->
                 ParserSExpr.$w$cshowsPrec 0 w w1) -}
eb4f10630146e346fe91afb9aaac5718
  $fShowAtom2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "I "#) -}
7977d78bb50242099c0673142dab04a3
  $fShowAtom3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "N "#) -}
bc3264b2fe8800129e52bb5e9611ac24
  $fShowAtom_$cshow :: ParserSExpr.Atom -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: ParserSExpr.Atom ->
                 ParserSExpr.$fShowAtom_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bc3264b2fe8800129e52bb5e9611ac24
  $fShowAtom_$cshowList :: [ParserSExpr.Atom] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ ParserSExpr.Atom
                   ParserSExpr.$fShowAtom1) -}
bc3264b2fe8800129e52bb5e9611ac24
  $fShowAtom_$cshowsPrec ::
    GHC.Types.Int -> ParserSExpr.Atom -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: ParserSExpr.Atom
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 ParserSExpr.$w$cshowsPrec ww1 w1 w2 }) -}
161f6f981a943215e3d8e21ed9851c81
  $fShowSExpr :: GHC.Show.Show ParserSExpr.SExpr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ParserSExpr.SExpr
                  ParserSExpr.$fShowSExpr_$cshowsPrec
                  ParserSExpr.$fShowSExpr_$cshow
                  ParserSExpr.$fShowSExpr_$cshowList -}
161f6f981a943215e3d8e21ed9851c81
  $fShowSExpr1 :: ParserSExpr.SExpr -> GHC.Show.ShowS
  {- Arity: 2 -}
1e516c59f123c57c6f471e00e2480bd2
  $fShowSExpr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Comb "#) -}
0356f62b5f612eca36c5b681dd945356
  $fShowSExpr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A "#) -}
161f6f981a943215e3d8e21ed9851c81
  $fShowSExpr_$cshow :: ParserSExpr.SExpr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: ParserSExpr.SExpr ->
                 ParserSExpr.$fShowSExpr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
161f6f981a943215e3d8e21ed9851c81
  $fShowSExpr_$cshowList :: [ParserSExpr.SExpr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ ParserSExpr.SExpr
                   ParserSExpr.$fShowSExpr1) -}
161f6f981a943215e3d8e21ed9851c81
  $fShowSExpr_$cshowsPrec ::
    GHC.Types.Int -> ParserSExpr.SExpr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: ParserSExpr.SExpr
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 ParserSExpr.$w$cshowsPrec1 ww1 w1 w2 }) -}
bc3264b2fe8800129e52bb5e9611ac24
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> ParserSExpr.Atom -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: ParserSExpr.Atom
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   ParserSExpr.N b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             ParserSExpr.$fShowAtom3
                             (case GHC.Show.$w$cshowsPrec1 11 b1 w1 of ww2 { (#,#) ww3 ww4 ->
                              GHC.Types.: @ GHC.Types.Char ww3 ww4 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                ParserSExpr.$fShowAtom3
                                (case GHC.Show.$w$cshowsPrec1
                                        11
                                        b1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows8
                                           w1) of ww2 { (#,#) ww3 ww4 ->
                                 GHC.Types.: @ GHC.Types.Char ww3 ww4 })) }
                   ParserSExpr.I b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             ParserSExpr.$fShowAtom2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                ParserSExpr.$fShowAtom2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
161f6f981a943215e3d8e21ed9851c81
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> ParserSExpr.SExpr -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: ParserSExpr.SExpr
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   ParserSExpr.A b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             ParserSExpr.$fShowSExpr3
                             (ParserSExpr.$w$cshowsPrec 11 b1 w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                ParserSExpr.$fShowSExpr3
                                (ParserSExpr.$w$cshowsPrec
                                   11
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   ParserSExpr.Comb b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             ParserSExpr.$fShowSExpr2
                             (GHC.Show.showList__
                                @ ParserSExpr.SExpr
                                ParserSExpr.$fShowSExpr1
                                b1
                                w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                ParserSExpr.$fShowSExpr2
                                (GHC.Show.showList__
                                   @ ParserSExpr.SExpr
                                   ParserSExpr.$fShowSExpr1
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) } }) -}
bc3264b2fe8800129e52bb5e9611ac24
  data Atom = N GHC.Integer.Type.Integer | I ParserSExpr.Ident
cf96d1c1615dc61ebfc5457844389af5
  type Ident = GHC.Base.String
161f6f981a943215e3d8e21ed9851c81
  data SExpr = A ParserSExpr.Atom | Comb [ParserSExpr.SExpr]
e5b24121349e83f0b7ead7db9256dc67
  parseSExpr :: Parser.Parser ParserSExpr.SExpr
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ParserSExpr.parseSExpr1
                  `cast`
                (Sym (Parser.NTCo:Parser[0] <ParserSExpr.SExpr>_R)) -}
7f0d8f8017dc816b5a7aa0d15e288986
  parseSExpr1 ::
    GHC.Base.String
    -> GHC.Base.Maybe (ParserSExpr.SExpr, GHC.Base.String)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ eta2 :: GHC.Base.String ->
                 Parser.$fApplicativeParser3
                   @ GHC.Base.String
                   @ ParserSExpr.SExpr
                   ParserSExpr.parseSExpr2
                     `cast`
                   (Sym (Parser.NTCo:Parser[0]
                             <GHC.Base.String -> ParserSExpr.SExpr>_R))
                   UsefulParsers.spaces
                   eta2) -}
8c54741702d47caf5409dacd444b0edb
  parseSExpr2 ::
    GHC.Base.String
    -> GHC.Base.Maybe
         (GHC.Base.String -> ParserSExpr.SExpr, GHC.Base.String)
  {- Arity: 1,
     Unfolding: (\ s :: GHC.Base.String[OneShot] ->
                 case Parser.$fApplicativeParser4
                        @ GHC.Base.String
                        @ ParserSExpr.SExpr
                        UsefulParsers.spaces
                        ParserSExpr.parseSExpr3
                          `cast`
                        (Sym (Parser.NTCo:Parser[0] <ParserSExpr.SExpr>_R))
                        s of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Base.String -> ParserSExpr.SExpr, GHC.Base.String)
                   GHC.Base.Just a2
                   -> GHC.Base.Just
                        @ (GHC.Base.String -> ParserSExpr.SExpr, GHC.Base.String)
                        (case a2 of wild1 { (,) a3 c ->
                         (\ ds :: GHC.Base.String -> a3, c) }) }) -}
53ffa6d4cee3e3e5420ee51664713e65
  parseSExpr3 ::
    GHC.Base.String
    -> GHC.Base.Maybe (ParserSExpr.SExpr, GHC.Base.String)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: GHC.Base.String ->
                 case UsefulParsers.posInt1 s of wild {
                   GHC.Base.Nothing
                   -> case s of wild1 {
                        []
                        -> Parser.$fApplicativeParser3
                             @ GHC.Types.Char
                             @ ParserSExpr.SExpr
                             ParserSExpr.parseSExpr5
                               `cast`
                             (Sym (Parser.NTCo:Parser[0]
                                       <GHC.Types.Char -> ParserSExpr.SExpr>_R))
                             ParserSExpr.parseSExpr4
                               `cast`
                             (Sym (Parser.NTCo:Parser[0] <GHC.Types.Char>_R))
                             (GHC.Types.[] @ GHC.Types.Char)
                        : x xs
                        -> case x of wild2 { GHC.Types.C# c# ->
                           case {__pkg_ccall base-4.8.2.0 u_iswalpha GHC.Prim.Int#
                                                                     -> GHC.Prim.State#
                                                                          GHC.Prim.RealWorld
                                                                     -> (# GHC.Prim.State#
                                                                             GHC.Prim.RealWorld,
                                                                           GHC.Prim.Int# #)}
                                  (GHC.Prim.ord# c#)
                                  GHC.Prim.realWorld# of wild3 { (#,#) ds ds1 ->
                           case ds1 of wild4 {
                             DEFAULT
                             -> case UsefulParsers.ident_eta2
                                       `cast`
                                     (Parser.NTCo:Parser[0] <[GHC.Types.Char]>_R)
                                       xs of wild5 {
                                  GHC.Base.Nothing
                                  -> Parser.$fApplicativeParser3
                                       @ GHC.Types.Char
                                       @ ParserSExpr.SExpr
                                       ParserSExpr.parseSExpr5
                                         `cast`
                                       (Sym (Parser.NTCo:Parser[0]
                                                 <GHC.Types.Char -> ParserSExpr.SExpr>_R))
                                       ParserSExpr.parseSExpr4
                                         `cast`
                                       (Sym (Parser.NTCo:Parser[0] <GHC.Types.Char>_R))
                                       wild1
                                  GHC.Base.Just x1
                                  -> case x1 of wild6 { (,) val rem' ->
                                     GHC.Base.Just
                                       @ (ParserSExpr.SExpr, GHC.Base.String)
                                       (ParserSExpr.A
                                          (ParserSExpr.I (GHC.Types.: @ GHC.Types.Char wild2 val)),
                                        rem') } }
                             0
                             -> Parser.$fApplicativeParser3
                                  @ GHC.Types.Char
                                  @ ParserSExpr.SExpr
                                  ParserSExpr.parseSExpr5
                                    `cast`
                                  (Sym (Parser.NTCo:Parser[0]
                                            <GHC.Types.Char -> ParserSExpr.SExpr>_R))
                                  ParserSExpr.parseSExpr4
                                    `cast`
                                  (Sym (Parser.NTCo:Parser[0] <GHC.Types.Char>_R))
                                  wild1 } } } }
                   GHC.Base.Just a2
                   -> GHC.Base.Just
                        @ (ParserSExpr.SExpr, GHC.Base.String)
                        (case a2 of wild1 { (,) a3 c ->
                         (ParserSExpr.A (ParserSExpr.N a3), c) }) }) -}
f23a5e63210e5aa40653e1a6e4fee2c2
  parseSExpr4 ::
    GHC.Base.String
    -> GHC.Base.Maybe (GHC.Types.Char, [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Base.String ->
                 case eta of wild {
                   [] -> GHC.Base.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                   : x xs
                   -> case x of wild1 { GHC.Types.C# c1 ->
                      case c1 of wild2 {
                        DEFAULT -> GHC.Base.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                        ')'
                        -> GHC.Base.Just
                             @ (GHC.Types.Char, [GHC.Types.Char])
                             (wild1, xs) } } }) -}
f1ffd9efc53d70d7a8b60048c3a3c1bc
  parseSExpr5 ::
    GHC.Base.String
    -> GHC.Base.Maybe
         (GHC.Types.Char -> ParserSExpr.SExpr, GHC.Base.String)
  {- Arity: 1,
     Unfolding: (\ s :: GHC.Base.String[OneShot] ->
                 case Parser.$fApplicativeParser4
                        @ GHC.Types.Char
                        @ ParserSExpr.SExpr
                        ParserSExpr.parseSExpr7
                          `cast`
                        (Sym (Parser.NTCo:Parser[0] <GHC.Types.Char>_R))
                        ParserSExpr.parseSExpr6
                          `cast`
                        (Sym (Parser.NTCo:Parser[0] <ParserSExpr.SExpr>_R))
                        s of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Char -> ParserSExpr.SExpr, GHC.Base.String)
                   GHC.Base.Just a2
                   -> GHC.Base.Just
                        @ (GHC.Types.Char -> ParserSExpr.SExpr, GHC.Base.String)
                        (case a2 of wild1 { (,) a3 c ->
                         (\ ds :: GHC.Types.Char -> a3, c) }) }) -}
7a5a3ca6255ab7bef2a3319cef05510a
  parseSExpr6 ::
    GHC.Base.String
    -> GHC.Base.Maybe (ParserSExpr.SExpr, GHC.Base.String)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 case ParserSExpr.parseSExpr_ds
                        `cast`
                      (Parser.NTCo:Parser[0] <[ParserSExpr.SExpr]>_R)
                        s of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing @ (ParserSExpr.SExpr, GHC.Base.String)
                   GHC.Base.Just a2
                   -> GHC.Base.Just
                        @ (ParserSExpr.SExpr, GHC.Base.String)
                        (case a2 of wild1 { (,) a3 c -> (ParserSExpr.Comb a3, c) }) }) -}
ceb043c95e0e448b6ab8d70b9b30ff8b
  parseSExpr7 ::
    GHC.Base.String
    -> GHC.Base.Maybe (GHC.Types.Char, [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Base.String ->
                 case eta of wild {
                   [] -> GHC.Base.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                   : x xs
                   -> case x of wild1 { GHC.Types.C# c1 ->
                      case c1 of wild2 {
                        DEFAULT -> GHC.Base.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                        '('
                        -> GHC.Base.Just
                             @ (GHC.Types.Char, [GHC.Types.Char])
                             (wild1, xs) } } }) -}
76f97229973fd2aa7b87db747da76aac
  parseSExpr_ds :: Parser.Parser [ParserSExpr.SExpr]
instance GHC.Show.Show [ParserSExpr.Atom] = ParserSExpr.$fShowAtom
instance GHC.Show.Show [ParserSExpr.SExpr]
  = ParserSExpr.$fShowSExpr
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

